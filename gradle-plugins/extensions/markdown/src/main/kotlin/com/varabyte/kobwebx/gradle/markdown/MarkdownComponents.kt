@file:Suppress("LeakingThis") // Following official Gradle guidance

package com.varabyte.kobwebx.gradle.markdown

import com.varabyte.kobweb.gradle.application.extensions.hasDependencyNamed
import org.commonmark.ext.gfm.tables.TableBlock
import org.commonmark.ext.gfm.tables.TableBody
import org.commonmark.ext.gfm.tables.TableCell
import org.commonmark.ext.gfm.tables.TableHead
import org.commonmark.ext.gfm.tables.TableRow
import org.commonmark.node.BulletList
import org.commonmark.node.Code
import org.commonmark.node.Emphasis
import org.commonmark.node.FencedCodeBlock
import org.commonmark.node.HardLineBreak
import org.commonmark.node.Heading
import org.commonmark.node.HtmlInline
import org.commonmark.node.Image
import org.commonmark.node.Link
import org.commonmark.node.ListItem
import org.commonmark.node.Node
import org.commonmark.node.OrderedList
import org.commonmark.node.Paragraph
import org.commonmark.node.StrongEmphasis
import org.commonmark.node.Text
import org.commonmark.node.ThematicBreak
import org.gradle.api.Project
import org.gradle.api.provider.Property
import javax.inject.Inject

private const val JB_DOM = "org.jetbrains.compose.web.dom"
private const val KOBWEB_DOM = "com.varabyte.kobweb.compose.dom"
private const val SILK = "com.varabyte.kobweb.silk.components"

class NodeScope {
    /** If set, will cause the Markdown visit to visit these nodes instead of the node's original children. */
    var childrenOverride: List<Node>? = null
}

/**
 * Specify which composable components should be used to render various html tags generated by the markdown parser.
 *
 * This block will be nested under [MarkdownConfig], e.g.
 *
 * ```
 * kobwebx {
 *   markdown {
 *     components { ... }
 *   }
 * }
 * ```
 */
abstract class MarkdownComponents @Inject constructor(project: Project) {
    /**
     * Use Silk components instead of Compose for Web components when relevant.
     *
     * If the user's project doesn't have a dependency on the Silk library, this should be set to false.
     */
    abstract val useSilk: Property<Boolean>

    /**
     * If true, attach an auto-generated header ID to each header element.
     *
     * For example,
     *
     * ```markdown
     * # This Is A Section
     * ```
     *
     * will generate a header tag with `id="this-is-a-section"`
     *
     * See also [idGenerator] if you need to override the default algorithm used for generating these IDs.
     */
    abstract val generateHeaderIds: Property<Boolean>

    /**
     * Handler for converting some incoming text (fairly unconstrained) into a final string value that should be used as
     * an ID for a URL fragment.
     *
     * By default, this simply only accepts letters and digits and converts everything else to hyphens (while removing
     * any duplicate neighboring hyphens), producing a lowercase value.
     *
     * However, if your project needs more fine-grained control over the generated names, you can set this callback
     * however you see fit.
     *
     * If you override this callback, you may want to check with https://www.rfc-editor.org/rfc/rfc3986 to ensure the ID
     * generated is valid.
     *
     * See also: [generateHeaderIds]
     */
    abstract val idGenerator: Property<(String) -> String>


    abstract val text: Property<NodeScope.(Text) -> String>
    abstract val img: Property<NodeScope.(Image) -> String>
    abstract val heading: Property<NodeScope.(Heading) -> String>
    abstract val p: Property<NodeScope.(Paragraph) -> String>
    abstract val br: Property<NodeScope.(HardLineBreak) -> String>
    abstract val a: Property<NodeScope.(Link) -> String>
    abstract val em: Property<NodeScope.(Emphasis) -> String>
    abstract val strong: Property<NodeScope.(StrongEmphasis) -> String>
    abstract val hr: Property<NodeScope.(ThematicBreak) -> String>
    abstract val ul: Property<NodeScope.(BulletList) -> String>
    abstract val ol: Property<NodeScope.(OrderedList) -> String>
    abstract val li: Property<NodeScope.(ListItem) -> String>
    abstract val code: Property<NodeScope.(FencedCodeBlock) -> String>
    abstract val inlineCode: Property<NodeScope.(Code) -> String>
    abstract val table: Property<NodeScope.(TableBlock) -> String>
    abstract val thead: Property<NodeScope.(TableHead) -> String>
    abstract val tbody: Property<NodeScope.(TableBody) -> String>
    abstract val tr: Property<NodeScope.(TableRow) -> String>
    abstract val td: Property<NodeScope.(TableCell) -> String>
    abstract val th: Property<NodeScope.(TableCell) -> String>

    /** Handler which is fed the raw text (name and attributes) within an opening tag, e.g. `span id="demo"` */
    abstract val rawTag: Property<NodeScope.(String) -> String>
    abstract val inlineTag: Property<NodeScope.(HtmlInline) -> String>

    init {
        project.afterEvaluate {
            useSilk.convention(project.hasDependencyNamed("kobweb-silk"))
        }

        generateHeaderIds.convention(true)
        idGenerator.convention { text ->
            val mergedText = text
                .map { c ->
                    when {
                        c.isLetterOrDigit() -> c.toLowerCase()
                        else -> '-'
                    }
                }
                .joinToString("")

            // Regexes are hard to read, so what's happening here is sometimes multiple special characters / spaces
            // could end up next to each other, causing double (or more) repeated dashes. We compress those so the
            // string doesn't look weird.
            mergedText
                .replace(Regex("""--+"""), "-")
                .removePrefix("-")
                .removeSuffix("-")
        }

        // region Markdown Node handlers

        text.convention { text ->
            val literal = text.literal.escapeQuotes()
            if (useSilk.get()) {
                "$SILK.text.Text(\"${literal}\")"
            } else {
                "$JB_DOM.Text(\"${literal}\")"
            }
        }
        img.convention { img ->
            val altText = img.children().filterIsInstance<Text>().map { it.literal }.joinToString("")
            this.childrenOverride = emptyList()

            if (useSilk.get()) {
                """$SILK.graphics.Image("${img.destination}", "$altText")"""
            } else {
                """$JB_DOM.Img("${img.destination}", "$altText")"""
            }
        }
        heading.convention { heading ->
            buildString {
                append("$JB_DOM.H${heading.level}")
                if (generateHeaderIds.get()) {
                    val text = heading.children()
                        .filterIsInstance<Text>()
                        .map { it.literal }
                        .joinToString("")
                    val id = idGenerator.get().invoke(text)
                    append("(attrs = { id(\"$id\") })")
                }
            }
        }
        p.convention { "$JB_DOM.P" }
        br.convention { "$JB_DOM.Br" }
        a.convention { link ->
            if (useSilk.get()) {
                val linkText = link.children().filterIsInstance<Text>().firstOrNull()?.literal?.escapeQuotes().orEmpty()
                childrenOverride = listOf() // We "consumed" the children, no more need to visit them
                "$SILK.navigation.Link(\"${link.destination}\", \"$linkText\")"
            } else {
                "$JB_DOM.A(\"${link.destination}\")"
            }
        }
        em.convention { "$JB_DOM.Em" }
        strong.convention { "$JB_DOM.B" }
        hr.convention {
            if (useSilk.get()) {
                "$SILK.layout.Divider"
            } else {
                "$JB_DOM.Hr"
            }
        }
        ul.convention { "$JB_DOM.Ul" }
        ol.convention { "$JB_DOM.Ol" }
        li.convention { "$JB_DOM.Li" }
        code.convention { codeBlock ->
            val text = "\"\"\"${codeBlock.literal}\"\"\""
            // Code blocks should generate <pre><code>...</code></pre>
            // https://daringfireball.net/projects/markdown/syntax#precode
            "$JB_DOM.Pre { $JB_DOM.Code { $JB_DOM.Text($text) } }"
        }
        inlineCode.convention { code ->
            childrenOverride = listOf(Text(code.literal))
            "$JB_DOM.Code"
        }
        table.convention { "$JB_DOM.Table" }
        thead.convention { "$JB_DOM.Thead" }
        tbody.convention { "$JB_DOM.Tbody" }
        tr.convention { "$JB_DOM.Tr" }
        td.convention { "$JB_DOM.Td" }
        th.convention { "$JB_DOM.Th" }

        fun String.stripTagBrackets() =
            this.removePrefix("</").removePrefix("<").removeSuffix("/>").removeSuffix(">")

        rawTag.convention { tag ->
            val parts = tag.stripTagBrackets().split(' ', limit = 2)
            val name = "\"${parts[0]}\""
            val attrs = parts.getOrNull(1)?.escapeQuotes()?.let { "\"$it\""} ?: "null"

            "$KOBWEB_DOM.GenericTag($name, $attrs)"
        }

        inlineTag.set { htmlInline ->
            val tag = htmlInline.literal

            val scope = this
            buildString {
                if (!tag.startsWith("</")) {
                    append(rawTag.get().invoke(scope, tag))
                    if (!tag.endsWith("/>")) {
                        append(" {")
                    }
                } else {
                    // Closing tag
                    append("}")
                }
            }
        }

        // endregion
    }
}