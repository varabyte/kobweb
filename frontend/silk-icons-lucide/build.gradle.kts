plugins {
    alias(libs.plugins.kotlin.multiplatform)
    id("kobweb-compose")
    id("com.varabyte.kobweb.internal.publish")
}

group = "com.varabyte.kobwebx"
version = libs.versions.kobweb.get()

private val GENERATED_SRC_ROOT = "build/generated/icons/src/jsMain/kotlin"

val generateIconsTask = tasks.register("generateIcons") {
    val srcFile = layout.projectDirectory.file("lucide-icons.json")
    val dstFile =
        layout.projectDirectory.file("$GENERATED_SRC_ROOT/com/varabyte/kobweb/silk/components/icons/lucide/LucideIcons.kt")

    inputs.files(srcFile)
    outputs.dir(GENERATED_SRC_ROOT)

    doLast {
        if (!srcFile.asFile.exists()) {
            throw GradleException(
                """
                |lucide-icons.json not found!
                |
                |To generate the icon data file:
                |1. cd frontend/silk-icons-lucide
                |2. npm install lucide@latest
                |3. node extract-icons.js
                |4. Run this task again
                |
                |See README.md for detailed instructions.
            """.trimMargin()
            )
        }

        val iconData = groovy.json.JsonSlurper().parse(srcFile.asFile) as Map<String, List<List<Any>>>

        // Generate individual composable functions
        val iconMethods = iconData.keys.sorted().joinToString("\n\n") { iconName ->
            // Convert icon name to composable function name, e.g. "a-arrow-down" -> "LiAArrowDown"
            @Suppress("DEPRECATION") // capitalize is way more readable than a direct replacement
            val methodName = "Li" + iconName.split("-").joinToString("") {
                it.capitalize()
            }

            val elements = iconData[iconName]!!
            val elementsCode = elements.joinToString(", ") { element ->
                val elementList = element as List<Any>
                val elementType = elementList[0] as String
                val attributes = elementList[1] as Map<String, String>
                val attrsString = attributes.entries.joinToString(", ") {
                    "\"${it.key}\" to \"${it.value}\""
                }
                "\"$elementType\" to mapOf($attrsString)"
            }

            """@Composable
fun $methodName(
    modifier: Modifier = Modifier,
    size: CSSLengthValue = 1.em,
    strokeWidth: Number = 2,
    color: CSSColorValue? = null
) {
    renderIcon(
        listOf($elementsCode),
        modifier, size, strokeWidth, color
    )
}"""
        }

        val iconsCode =
            """
            |// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            |// THIS FILE IS AUTOGENERATED.
            |//
            |// Do not edit this file by hand. Instead, update `lucide-icons.json` in the module root and run the Gradle
            |// task "generateIcons"
            |// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            |
            |package com.varabyte.kobweb.silk.components.icons.lucide
            |
            |import androidx.compose.runtime.Composable
            |import com.varabyte.kobweb.compose.ui.Modifier
            |import com.varabyte.kobweb.compose.ui.toAttrs
            |import com.varabyte.kobweb.compose.dom.svg.Circle
            |import com.varabyte.kobweb.compose.dom.svg.Line
            |import com.varabyte.kobweb.compose.dom.svg.Path
            |import com.varabyte.kobweb.compose.dom.svg.Polygon
            |import com.varabyte.kobweb.compose.dom.svg.Polyline
            |import com.varabyte.kobweb.compose.dom.svg.Rect
            |import com.varabyte.kobweb.compose.dom.svg.ViewBox
            |import com.varabyte.kobweb.silk.components.icons.createIcon
            |import com.varabyte.kobweb.silk.components.icons.IconRenderStyle
            |import org.jetbrains.compose.web.css.*
            |
            |@Composable
            |private fun renderIcon(
            |    elements: List<Pair<String, Map<String, String>>>,
            |    modifier: Modifier = Modifier,
            |    size: CSSLengthValue = 1.em,
            |    strokeWidth: Number = 2,
            |    color: CSSColorValue? = null
            |) {
            |    createIcon(
            |        viewBox = ViewBox.sized(24),
            |        width = size,
            |        renderStyle = IconRenderStyle.Stroke(strokeWidth),
            |        attrs = modifier.toAttrs {
            |            if (color != null) {
            |                attr("stroke", color.toString())
            |            }
            |            attr("fill", "none")
            |            attr("stroke-linecap", "round")
            |            attr("stroke-linejoin", "round")
            |        }
            |    ) {
            |        elements.forEach { (elementType, attributes) ->
            |            when (elementType) {
            |                "path" -> {
            |                    Path {
            |                        attributes["d"]?.let { d(it) }
            |                    }
            |                }
            |                "circle" -> {
            |                    Circle {
            |                        attributes["cx"]?.let { cx(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["cy"]?.let { cy(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["r"]?.let { r(it.toDoubleOrNull() ?: 0.0) }
            |                    }
            |                }
            |                "rect" -> {
            |                    Rect {
            |                        attributes["x"]?.let { x(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["y"]?.let { y(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["width"]?.let { width(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["height"]?.let { height(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["rx"]?.let { rx(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["ry"]?.let { ry(it.toDoubleOrNull() ?: 0.0) }
            |                    }
            |                }
            |                "line" -> {
            |                    Line {
            |                        attributes["x1"]?.let { x1(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["y1"]?.let { y1(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["x2"]?.let { x2(it.toDoubleOrNull() ?: 0.0) }
            |                        attributes["y2"]?.let { y2(it.toDoubleOrNull() ?: 0.0) }
            |                    }
            |                }
            |                "polyline" -> {
            |                    Polyline {
            |                        attributes["points"]?.let { pointsStr ->
            |                            // Parse "x1,y1 x2,y2 ..." format
            |                            val pairs = pointsStr.split(" ").mapNotNull { point ->
            |                                val coords = point.split(",")
            |                                if (coords.size == 2) {
            |                                    val x = coords[0].toDoubleOrNull()
            |                                    val y = coords[1].toDoubleOrNull()
            |                                    if (x != null && y != null) x to y else null
            |                                } else null
            |                            }
            |                            if (pairs.isNotEmpty()) {
            |                                points(*pairs.toTypedArray())
            |                            }
            |                        }
            |                    }
            |                }
            |                "polygon" -> {
            |                    Polygon {
            |                        attributes["points"]?.let { pointsStr ->
            |                            // Parse "x1,y1 x2,y2 ..." format
            |                            val pairs = pointsStr.split(" ").mapNotNull { point ->
            |                                val coords = point.split(",")
            |                                if (coords.size == 2) {
            |                                    val x = coords[0].toDoubleOrNull()
            |                                    val y = coords[1].toDoubleOrNull()
            |                                    if (x != null && y != null) x to y else null
            |                                } else null
            |                            }
            |                            if (pairs.isNotEmpty()) {
            |                                points(*pairs.toTypedArray())
            |                            }
            |                        }
            |                    }
            |                }
            |            }
            |        }
            |    }
            |}
            |
            |$iconMethods
            """.trimMargin()

        dstFile.asFile.apply {
            parentFile.mkdirs()
            writeText(iconsCode)
        }

        println("Generated ${iconData.size} Lucide icon composables")
    }
}

kotlin {
    js {
        browser()
    }

    sourceSets {
        jsMain {
            kotlin.srcDir(generateIconsTask)

//            kotlin.srcDir(GENERATED_SRC_ROOT)
            dependencies {
                implementation(libs.compose.runtime)
                implementation(libs.compose.html.core)

                api(projects.frontend.kobwebCompose)
                implementation(projects.frontend.composeHtmlExt)  // For SVG components
                implementation(projects.frontend.silkWidgets)     // For createIcon
            }
        }
    }
}

//// Ensure icons are generated before compilation
//tasks.named("compileKotlinJs") {
//    dependsOn(generateIconsTask)
//}

kobwebPublication {
    artifactName.set("Kobweb Silk Icons (Lucide)")
    artifactId.set("silk-icons-lucide")
    description.set("A collection of composables that directly wrap Lucide icons.")
}